// --- DENTRO DE LA FUNCIÓN update() ---

// Lógica de Fantasmas Corregida
ghosts.forEach(g => {
    if (g.x % TILE_SIZE === 0 && g.y % TILE_SIZE === 0) {
        const gx = Math.round(g.x / TILE_SIZE);
        const gy = Math.round(g.y / TILE_SIZE);
        
        const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        
        // Filtramos direcciones válidas:
        // 1. Que estén dentro del mapa.
        // 2. Que no sean una pared (valor 1).
        let validDirs = dirs.filter(d => {
            const nextY = gy + d[1];
            const nextX = gx + d[0];
            return map[nextY] !== undefined && 
                   map[nextY][nextX] !== undefined && 
                   map[nextY][nextX] !== 1;
        });

        if (validDirs.length > 0) {
            // Evitar que el fantasma se dé la vuelta 180 grados de golpe (opcional, hace el movimiento más natural)
            let filteredDirs = validDirs.filter(d => !(d[0] === -g.dirX && d[1] === -g.dirY));
            let finalDirs = filteredDirs.length > 0 ? filteredDirs : validDirs;
            
            let choice = finalDirs[Math.floor(Math.random() * finalDirs.length)];
            g.dirX = choice[0]; 
            g.dirY = choice[1];
        }
    }
    
    // Aplicar movimiento
    g.x += g.dirX * g.speed;
    g.y += g.dirY * g.speed;

    // --- TELETRANSPORTE LATERAL (Túneles) ---
    // Si salen por la izquierda, aparecen por la derecha y viceversa
    if (g.x < -TILE_SIZE) g.x = canvas.width;
    if (g.x > canvas.width) g.x = -TILE_SIZE;

    // Colisión con jugador
    let dist = Math.hypot(player.x - g.x, player.y - g.y);
    if (dist < TILE_SIZE * 0.8) { // Ajuste de colisión ligeramente más permisivo
        if (g.scared) {
            g.x = 9 * TILE_SIZE; 
            g.y = 9 * TILE_SIZE;
            score += 200;
            g.scared = false;
        } else {
            resetPlayer();
        }
    }
});
